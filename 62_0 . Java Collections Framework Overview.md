

## 🔷 Java Collections Framework Overview

The Java Collections Framework is a set of **interfaces and classes** that handle **groups of objects** (collections). It is present in `java.util` package.

---

## 🔷 Main Interfaces in Collections

| Interface                      | Description                                 | Implementations                                    |
| ------------------------------ | ------------------------------------------- | -------------------------------------------------- |
| `Collection`                   | Root interface (List, Set, Queue extend it) | `ArrayList`, `HashSet`, etc.                       |
| `List`                         | Ordered, allows duplicates                  | `ArrayList`, `LinkedList`, `Vector`                |
| `Set`                          | Unordered, **no duplicates**                | `HashSet`, `LinkedHashSet`, `TreeSet`              |
| `Queue`                        | FIFO order                                  | `PriorityQueue`, `ArrayDeque`                      |
| `Deque`                        | Double-ended Queue                          | `ArrayDeque`                                       |
| `Map` (Not part of Collection) | Key-value pairs                             | `HashMap`, `LinkedHashMap`, `TreeMap`, `Hashtable` |

---

## 🔶 Differences Between All Collection Types

### 1. 🔹 List vs Set vs Queue vs Map

| Feature            | List                  | Set                             | Queue                         | Map                                                 |
| ------------------ | --------------------- | ------------------------------- | ----------------------------- | --------------------------------------------------- |
| Duplicates Allowed | ✅ Yes                 | ❌ No                            | ✅ Yes (depends)               | ❌ Keys must be unique                               |
| Ordered            | ✅ Yes (index-based)   | ❌ (except `LinkedHashSet`)      | ✅ FIFO (except PriorityQueue) | ✅ Yes (LinkedHashMap, TreeMap)                      |
| Null Values        | ✅ Multiple            | ✅ One null only                 | ✅ Depends                     | ✅ One null key, many null values (except Hashtable) |
| Access             | By index              | By iterator                     | Head/tail access              | By key                                              |
| Common Classes     | ArrayList, LinkedList | HashSet, LinkedHashSet, TreeSet | PriorityQueue, ArrayDeque     | HashMap, TreeMap, LinkedHashMap                     |

---

## 🔶 Differences Within Implementations

### 2. 🔹 List Implementations

| Feature            | ArrayList     | LinkedList             | Vector              |
| ------------------ | ------------- | ---------------------- | ------------------- |
| Internal Structure | Dynamic Array | Doubly Linked List     | Synchronized Array  |
| Insertion Time     | O(1) (end)    | O(1) (beginning/end)   | O(1)                |
| Random Access      | ✅ Fast (O(1)) | ❌ Slow (O(n))          | ✅ Fast (O(1))       |
| Thread-Safe        | ❌ No          | ❌ No                   | ✅ Yes (legacy)      |
| Use Case           | Frequent read | Frequent insert/delete | Multi-threaded list |

---

### 3. 🔹 Set Implementations

| Feature      | HashSet         | LinkedHashSet     | TreeSet                       |
| ------------ | --------------- | ----------------- | ----------------------------- |
| Order        | ❌ No            | ✅ Insertion order | ✅ Sorted (natural/comparator) |
| Duplicates   | ❌ No            | ❌ No              | ❌ No                          |
| Performance  | ✅ Fast (O(1))   | ⬇ Slightly slower | ❌ Slower (O(log n))           |
| Null Allowed | ✅ One null      | ✅ One null        | ❌ No (throws NPE)             |
| Use Case     | Unique elements | Unique & ordered  | Sorted unique data            |

---

### 4. 🔹 Queue & Deque Implementations

| Feature      | PriorityQueue    | ArrayDeque       |
| ------------ | ---------------- | ---------------- |
| Order        | ✅ Priority order | ✅ FIFO / LIFO    |
| Null Allowed | ❌ No             | ❌ No             |
| Thread-Safe  | ❌ No             | ❌ No             |
| Use Case     | Task scheduling  | Stack/Queue both |

---

### 5. 🔹 Map Implementations

| Feature          | HashMap       | LinkedHashMap     | TreeMap             | Hashtable              |
| ---------------- | ------------- | ----------------- | ------------------- | ---------------------- |
| Order            | ❌ No          | ✅ Insertion order | ✅ Sorted            | ❌ No                   |
| Null Keys/Values | ✅ 1 null key  | ✅ 1 null key      | ❌ No null key       | ❌ No null key/value    |
| Thread-Safe      | ❌ No          | ❌ No              | ❌ No                | ✅ Yes (legacy)         |
| Performance      | ✅ Fast (O(1)) | Slightly slower   | ❌ Slower (O(log n)) | Slower than HashMap    |
| Use Case         | Fast lookups  | Cache (LRU style) | Sorted map          | Legacy thread-safe map |

---

## 🔷 Summary Table

| Category      | Ordered        | Duplicates  | Thread-Safe | Sorted | Null Allowed   | Performance     |
| ------------- | -------------- | ----------- | ----------- | ------ | -------------- | --------------- |
| ArrayList     | ✅ Yes          | ✅ Yes       | ❌ No        | ❌ No   | ✅ Yes          | ✅ Fast          |
| LinkedList    | ✅ Yes          | ✅ Yes       | ❌ No        | ❌ No   | ✅ Yes          | ✅ Fast (insert) |
| HashSet       | ❌ No           | ❌ No        | ❌ No        | ❌ No   | ✅ One null     | ✅ Fast          |
| LinkedHashSet | ✅ Yes          | ❌ No        | ❌ No        | ❌ No   | ✅ One null     | ⬇ Medium        |
| TreeSet       | ✅ Yes (Sorted) | ❌ No        | ❌ No        | ✅ Yes  | ❌ No           | ❌ Slower        |
| HashMap       | ❌ No           | ❌ No (keys) | ❌ No        | ❌ No   | ✅ One null key | ✅ Fast          |
| LinkedHashMap | ✅ Yes          | ❌ No        | ❌ No        | ❌ No   | ✅ One null key | ⬇ Medium        |
| TreeMap       | ✅ Yes (Sorted) | ❌ No        | ❌ No        | ✅ Yes  | ❌ No           | ❌ Slower        |
| Hashtable     | ❌ No           | ❌ No        | ✅ Yes       | ❌ No   | ❌ No           | ❌ Slower        |

---

## 🔷 Real-Time Use Cases

| Collection      | Use Case Example                            |
| --------------- | ------------------------------------------- |
| `ArrayList`     | Store list of students, products, etc.      |
| `LinkedList`    | Implement Stack, Queue                      |
| `HashSet`       | Store unique emails, IDs                    |
| `LinkedHashSet` | Maintain insertion order in unique elements |
| `TreeSet`       | Sorted usernames                            |
| `HashMap`       | EmployeeID → Name                           |
| `LinkedHashMap` | LRU Cache                                   |
| `TreeMap`       | Sorted dictionary                           |
| `Hashtable`     | Legacy multi-threaded apps                  |

---

## 🔷 Conclusion

* Use **List** when order and duplicates matter.
* Use **Set** for uniqueness.
* Use **Queue/Deque** for scheduling and ordering.
* Use **Map** when key-value pairs are needed.
* Choose **thread-safe versions** if required in concurrency scenarios.

